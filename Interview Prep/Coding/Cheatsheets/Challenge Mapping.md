| Problem                                          | Category                   | General Solution Idea                                                                                                                              |
| ------------------------------------------------ | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **125. Valid Palindrome**                        | String / Two-Pointers      | Use two pointers from left/right, skip non-alphanumeric chars, compare lowercase letters.                                                          |
| **227. Basic Calculator II**                     | String Parsing / Stack     | Scan string, build numbers; apply last operator; use stack to handle `+`, `-`, `*`, `/` precedence. Sum stack at end.                              |
| **236. Lowest Common Ancestor of a Binary Tree** | Binary Tree / DFS          | Recursively search left & right; if one node found in each side → current node is LCA. Return non-null child otherwise.                            |
| **339. Nested List Weight Sum**                  | DFS / BFS                  | Traverse nested list recursively (DFS) or level by level (BFS). Multiply each integer by its depth and sum.                                        |
| **528. Random Pick with Weight**                 | Prefix Sum + Binary Search | Build prefix sums of weights. Pick random number in `[1, total]`. Binary search in prefix to find index.                                           |
| **50. Pow(x, n)**                                | Binary Exponentiation      | Use fast exponentiation (divide & conquer). Recurse/iterate: `x^n = (x^(n/2))^2`, handle odd exponent separately. O(log n).                        |
| **88. Merge Sorted Array**                       | Two-Pointers               | Fill `nums1` from the back using two pointers (end of `nums1`’s elements, end of `nums2`). Compare and place larger.                               |
| **199. Binary Tree Right Side View**             | BFS / DFS                  | BFS level order: take last node at each level. DFS right-first preorder: first node seen at each depth. Collect into result.                       |
| **297. Serialize and Deserialize Binary Tree**   | Binary Tree / BFS / DFS    | Serialize with BFS (level order) or DFS preorder + markers for null. Deserialize by reversing the process.                                         |
| **564. Find the Closest Palindrome**             | String / Math              | Generate palindrome candidates by mirroring prefix, adjusting mid (+1/–1). Compare distances to find closest (exclude self if already palindrome). |
| **545. Boundary of Binary Tree**                 | Binary Tree Traversal      | Collect left boundary (excluding leaves), then leaves (left to right), then right boundary (excluding leaves, reversed).                           |
| **523. Continuous Subarray Sum**                 | Prefix Sum + Hash Map      | Track prefix sum modulo k. If the same remainder seen before at least 2 indices apart → subarray sum divisible by k.                               |
| **527. Word Abbreviation**                       | String / Hashing / Trie    | Generate abbreviations by prefix + count + last char. If conflicts, increase prefix length. Use hashing or trie to ensure uniqueness.              |
